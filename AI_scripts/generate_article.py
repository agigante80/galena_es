import os
import logging
import requests
import csv
from datetime import datetime
from openai import OpenAI
import re
from markdown_it import MarkdownIt
from markdown_it.renderer import RendererHTML
from PIL import Image
from io import BytesIO
import time
import random

# The following variables must be set as environment variables for security reasons.
# OPENAI_API_KEY
# TELEGRAM_BOT_TOKEN
# TELEGRAM_CHAT_ID
# INDEXNOW_API_KEY
#
# INDEXNOW_API_KEY is the variables for the IndexNow API
# This is your own IndexNow API key. You can get it at https://indexnow.org/
# If you don't want to use IndexNow, you can leave this variable empty.
#
# In Github, you can set them in the repository settings:
# - Go to your repository on GitHub.
# - Click on the "Settings" tab.
# - In the left sidebar, click on "Secrets and variables" and then "Actions".
# - Click the "New repository secret" button.
#
#  If you run the script locally, you can set them in the terminal before running the script.
# export OPENAI_API_KEY=""
# export TELEGRAM_BOT_TOKEN=""
# export TELEGRAM_CHAT_ID=""
# 
# If you use Windows, you can set them in the terminal before running the script.
# set OPENAI_API_KEY=""
# set TELEGRAM_BOT_TOKEN=""
# set TELEGRAM_CHAT_ID=""
# 
# If you want to set them in the script for TESTING purposes, you can uncomment the following lines.
# OPENAI_API_KEY = ""
# TELEGRAM_BOT_TOKEN = ""
# TELEGRAM_CHAT_ID = ""

# Settting the variables for managing the topics
AI_TOPICS_DIRECTORY = "AI_content/"
CSV_FILE_LIST_OF_NEW_TOPICS = "list_of_NEW_topics.csv"
CSV_FILE_LIST_OF_ARCHIVED_TOPICS = "list_of_ARCHIVED_topics.csv"
CSV_FILE_LIST_OF_ERROR_TOPICS = "list_of_ERROR_topics.csv"

# Settting the variables for the images generated by the AI
AI_IMAGES_DIRECTORY = "assets/images/"

# Settting the variables for the articles generated by the AI
AI_ARTICLES_DIRECTORY = "_posts/"

# Settting the variables for logs
LOG_FULL_PATH = ""

# Settting the variables for the website
WEBSITE = "https://galena.es/"

# Set up logging.
# The logging configuration checks if LOG_FULL_PATH is set. 
# If it is not set, logging is configured to use the default settings, which log to the console. 
# This ensures that the script continues to run even if LOG_FULL_PATH is empty.
if LOG_FULL_PATH:
    logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s', filename=LOG_FULL_PATH, filemode='a')
else:
    logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

logging.info("‚úÖ Script started...")

def check_env_variable_error(var_name):
    """Check if a required environment variable is set. 
    Log an error and raise an exception if missing.
    
    Args:
        var_name (str): The name of the environment variable to check.
    
    Returns:
        str: The value of the environment variable.
    """
    value = os.getenv(var_name)
    if not value:
        logging.error(f"‚ùå [Environment Variable Error] {var_name} is missing! Please set it as an environment variable.")
        raise ValueError(f"‚ùå [Environment Variable Error] {var_name} is missing! Please set it as an environment variable.")
    else:
        logging.debug(f"‚úÖ [Environment Variable Loaded] {var_name} successfully loaded with value: {value[:4]}***")
    return value

def check_env_variable_warning(var_name):
    """Check if an optional environment variable is set. 
    Log a warning if missing.
    
    Args:
        var_name (str): The name of the environment variable to check.
    
    Returns:
        str or None: The value of the environment variable, or None if not set.
    """
    value = os.getenv(var_name)
    if not value:
        logging.warning(f"‚ö†Ô∏è [Environment Variable Warning] {var_name} is missing! Please set it as an environment variable.")
        return None
    else:
        logging.debug(f"‚úÖ [Environment Variable Loaded] {var_name} successfully loaded with value: {value[:4]}***")
    return value

def initialize_csv(file_path):
    """Ensure a CSV file exists. Create it if it does not exist.
    
    Args:
        file_path (str): The path to the CSV file.
    """
    try:
        if not os.path.exists(file_path):
            with open(file_path, 'w', newline='') as file:
                logging.info(f"‚úÖ [CSV Initialization] Created new CSV file: {file_path}")
        else:
            logging.debug(f"‚úÖ [CSV Initialization] CSV file already exists: {file_path}")
    except PermissionError:
        logging.critical(f"‚ùå [CSV Initialization Error] Permission denied: Unable to create or access the file at {file_path}. Check file permissions.")
    except FileNotFoundError:
        logging.error(f"‚ùå [CSV Initialization Error] File not found: The directory for {file_path} does not exist. Ensure the directory is created.")
    except Exception as e:
        logging.error(f"‚ùå [CSV Initialization Error] Unexpected error while initializing CSV file: {file_path}. Error: {e}")

def write_to_csv(file_path, topic_idea, description):
    """Append a topic idea and description to a CSV file.
    
    Args:
        file_path (str): The path to the CSV file.
        topic_idea (str): The topic idea to write.
        description (str): The description to write.
    """
    try:
        with open(file_path, 'a', newline='') as error_file:
            writer = csv.writer(error_file)
            logging.debug(f"[CSV Write] Writing to file: {file_path} -> Topic: {topic_idea}, Description: {description}")
            writer.writerow([topic_idea, description])
        logging.info(f"‚úÖ [CSV Write] Topic: '{topic_idea}', Description: '{description}' successfully written to file: {file_path}")
    except Exception as file_error:
        logging.error(f"‚ùå [CSV Write Error] Failed to write to file: {file_path}. Error: {file_error}")
        raise

def retry_with_backoff(func, max_retries=3, initial_delay=1, backoff_factor=2, *args, **kwargs):
    """Retry a function with exponential backoff in case of failure.
    
    Args:
        func (callable): The function to retry.
        max_retries (int): Maximum number of retries.
        initial_delay (int): Initial delay in seconds before retrying.
        backoff_factor (int): Factor by which the delay increases after each retry.
        *args: Positional arguments for the function.
        **kwargs: Keyword arguments for the function.
    
    Returns:
        Any: The return value of the function if successful.
    
    Raises:
        Exception: The last exception raised if all retries fail.
    """
    delay = initial_delay
    for attempt in range(max_retries):
        try:
            return func(*args, **kwargs)
        except Exception as e:
            if attempt < max_retries - 1:
                logging.warning(f"‚ö†Ô∏è [Retry] Attempt {attempt + 1} failed. Retrying in {delay} seconds...")
                time.sleep(delay)
                delay *= backoff_factor
            else:
                logging.error(f"‚ùå [Retry] All {max_retries} attempts failed. Last error: {e}")
                raise

def send_telegram_message(bot_token, chat_id, message):
    """Send a message to a Telegram chat using a bot with retry logic.
    
    Args:
        bot_token (str): The Telegram bot token.
        chat_id (str): The Telegram chat ID.
        message (str): The message to send.
    """
    if not bot_token or not chat_id:
        logging.warning("‚ö†Ô∏è [Telegram Warning] Telegram message not sent due to missing TELEGRAM_BOT_TOKEN or TELEGRAM_CHAT_ID.")
        return

    message = f"{WEBSITE}\n{message}"  # Add the website to the message

    url = f"https://api.telegram.org/bot{bot_token}/sendMessage"
    data = {'chat_id': chat_id, 'text': message}

    def send_request():
        response = requests.post(url, data=data, timeout=10)
        if response.status_code == 200:
            logging.info(f"‚úÖ [Telegram] Message sent successfully to chat ID: {chat_id}")
        else:
            raise Exception(f"Failed to send message. Status code: {response.status_code}, Response: {response.text}")

    retry_with_backoff(send_request)

def get_topics_create_csv_and_notify(api_key, file_path, bot_token, chat_id):
    """Generate 10 blog topic ideas using OpenAI, save them to a CSV file, and notify via Telegram.
    
    Args:
        api_key (str): The OpenAI API key.
        file_path (str): The path to the CSV file for storing topics.
        bot_token (str): The Telegram bot token.
        chat_id (str): The Telegram chat ID.
    
    Returns:
        str: The generated topics as a string.
    """
    # Fetches the next 10 topics.
    prompt = """
Objective: Generate 10 engaging and insightful topic ideas for my blog at www.galena.es, focused on exploring the world of minerals, mining, and gemstones. This blog aims to be the go-to destination for geology enthusiasts, jewelry lovers, and anyone curious about the natural world.

Requirements:

- Provide 10 unique and original topic ideas.
- Format the response in CSV style without a header, directly starting with the content.
- Constraints:
  - Topic Idea: Must be no longer than 50 characters, engaging, original, and contain no symbols or punctuation, including periods comas and hyphens.
  - Description: Must be a brief one-sentence explanation no longer than 150 characters, containing no symbols or punctuation, including periods comas and hyphens.
  - Do not number each line
  - Do not use any punctuation in the topic ideas or descriptions

Example for the Format:

Topic Idea, Description

Output Example Structure:

Understanding Mineral Veins, Learn about the formation and economic significance of mineral veins in geological structures
Gemstones and Their Origins, Explore how different gemstones are formed and the geographical regions where they are found
Mining Innovations Today, Discover the latest technological advancements in the mining industry and their impact on efficiency and safety
The Beauty of Raw Gems, Examine the natural aesthetics of raw gemstones and their unique appeal in modern jewelry design
Sustainable Gemstone Sources, Understand the importance of ethically sourced gemstones and the efforts to ensure environmental sustainability
Gold Through the Ages, Delve into the historical significance of gold and its evolving role in economy and culture
Crystal Healing Myths, Evaluate the science and beliefs behind crystals and their purported healing properties
Artisan Jewelers Stories, Explore how independent jewelers are creating unique pieces with personal and cultural narratives
Future of Mineral Exploration, Look at emerging trends in the exploration of minerals with a focus on sustainability
The Science of Gem Cutting, Learn about the precision and artistry involved in cutting gemstones to enhance their beauty and value

Additional Instructions:

- Ensure the topics are relevant to minerals, mining, or gemstones.
- Consider incorporating current trends, scientific discoveries, or historical perspectives.
- Aim to provide value to both industry experts and curious learners.
"""
    client = OpenAI(
            api_key=api_key,  # Pass the api_key directly
        )    
    response = client.chat.completions.create(
    model="gpt-4",
    messages=[
            {"role": "system", "content": "You are a helpful assistant."},
            {"role": "user", "content": prompt}
        ],
        max_tokens=500,
        # The max_tokens parameter controls the length of the generated output 
        # by specifying the maximum number of tokens the model is allowed to produce.
        n=1,
        # The n parameter specifies how many different completion choices the model should generate. 
        # By setting n=1, the function instructs the model to produce only one completion choice for the given input. 
        # This is useful when you want a single, straightforward response without additional alternatives.
        temperature=0.7,
        # The temperature parameter controls the randomness of the output.
        # A value of 0.7 is chosen to balance creativity and coherence.
    )
    topics = response.choices[0].message.content.strip()
    logging.info(topics)
    
    # Write topics to the CSV file
    with open(file_path, 'a') as file:
        writer = csv.writer(file)
        for line in topics.split('\n'):
            # Clean the line using regular expressions
            cleaned_line = re.sub(r'["‚Äú‚Äù]', '', line).strip()
            writer.writerow(cleaned_line.split(', '))
    
    if topics:
        logging.info("‚úÖ 10 topics were written to CSV file.")
        send_telegram_message(bot_token, chat_id, "New 10 topics have been generated and saved.")
    else:
        logging.error("‚ùå Failed to generate 10 topics.")
    
    return topics

def fetch_topic_and_description(file_path, api_key, bot_token, chat_id):
    """Fetch the next topic idea and description from a CSV file. 
    Generate new topics if the file is empty.
    
    Args:
        file_path (str): The path to the CSV file.
        api_key (str): The OpenAI API key.
        bot_token (str): The Telegram bot token.
        chat_id (str): The Telegram chat ID.
    
    Returns:
        tuple: A tuple containing the topic idea and description.
    """
    #Fetches the next blog Topic Idea and Description from the CSV.
    with open(file_path, 'r') as infile:
        reader = csv.reader(infile)
        lines = list(reader)

    if not lines:
        logging.info("üîÑ CSV is empty, generating new topics...")
        get_topics_create_csv_and_notify(api_key, file_path, bot_token, chat_id)
        return fetch_topic_and_description(file_path, api_key, bot_token, chat_id)

    topic_idea, description = lines[0]
    # Remove the used line
    with open(file_path, 'w', newline='') as outfile:
        writer = csv.writer(outfile)
        writer.writerows(lines[1:])
    return topic_idea, description

def get_image_create_file_and_notify(api_key, file_path, bot_token, chat_id, topic_idea, description):
    """Generate an image using OpenAI, save it locally, and notify via Telegram with retry logic.
    
    Args:
        api_key (str): The OpenAI API key.
        file_path (str): The directory path to save the image.
        bot_token (str): The Telegram bot token.
        chat_id (str): The Telegram chat ID.
        topic_idea (str): The topic idea for the image.
        description (str): The description for the image.
    
    Returns:
        str: The path to the resized image.
    """
    prompt = f"""
    Task:
    Create an engaging illustration for a blog article on our website, ensuring it visually captures the essence of the topic provided.

    Details:

        Topic Idea: {topic_idea}
        Description: {description}

    Requirements:
        Focus: Highlight the mineral, emphasizing its distinctive features.
        Visual Style: Use a vibrant, educational style to capture attention.
        Audience: Designed for geology fans, educators, and earth science readers.
        Digital Quality: Optimize for digital display and printing, without guidance texts.
        Text-Free: Keep the image free of text, captions, and watermarks.
    """

    def generate_image():
        client = OpenAI(api_key=api_key)
        response = client.images.generate(
            model="dall-e-3",
            prompt=prompt,
            n=1,
            size='1024x1024',  # other options '256x256', '512x512', '1024x1024', '1024x1792', '1792x1024'
        )
        return response.data[0].url

    try:
        image_url = retry_with_backoff(generate_image)
        logging.info(f"‚úÖ [Image Generation] Generated Image URL: {image_url}")

        def download_image():
            response = requests.get(image_url, timeout=10)
            if response.status_code == 200:
                return response.content
            else:
                raise Exception(f"Failed to download image. Status code: {response.status_code}")

        image_content = retry_with_backoff(download_image)

        sanitized_topic = topic_idea.replace(' ', '_').replace("'", "")
        original_image_path = os.path.join(file_path, f"{sanitized_topic}_1024x1024.png")
        with open(original_image_path, 'wb') as image_file:
            image_file.write(image_content)
        logging.info(f"‚úÖ [Image Download] Original image downloaded and saved to {original_image_path}")

        # Resize the image
        with Image.open(BytesIO(image_content)) as original_image:
            resized_dimensions = (512, 512)  # Change dimensions as required
            resized_image = original_image.resize(resized_dimensions)

            # Save the resized image
            resized_image_path = os.path.join(file_path, f"{sanitized_topic}.png")
            resized_image.save(resized_image_path)
            logging.info(f"‚úÖ [Image Resize] Resized image saved to {resized_image_path}")

        return resized_image_path
    except Exception as e:
        logging.error(f"‚ùå [Image Generation Error] Failed to generate or download the image. Error: {e}")
        return None

def generate_image_alt_text(api_key, topic_idea, description):
    """Generate alt text for an image based on the topic idea and description.
    
    Args:
        api_key (str): The OpenAI API key.
        topic_idea (str): The topic idea for the image.
        description (str): The description for the image.
    
    Returns:
        str: The generated alt text.
    """
    prompt = f"""
Create a concise and descriptive alt text for an image related to the following:

- Topic Idea: {topic_idea}
- Description: {description}

The blog focuses on minerals, mining, or gemstones. The audience includes geology enthusiasts, educators, and general readers interested in earth sciences.
"""

    client = OpenAI(api_key=api_key)    
    response = client.chat.completions.create(
        model="gpt-4o-mini",
        messages=[
            {"role": "system", "content": "You are a helpful assistant."},
            {"role": "user", "content": prompt}
        ],
        max_tokens=100,
        n=1,
        temperature=0.5,
    )

    # Extract and clean the alt text by removing "Alt text: " if present
    image_alt_text = response.choices[0].message.content.strip()
    image_alt_text = image_alt_text.replace("Alt text: ", "").replace("Alt Text: ", "").replace("alt text: ", "").strip()

    logging.info(f"‚úÖ Generated alt text: {image_alt_text}")
    return image_alt_text


def notify_indexnow(api_key, url):
    """Notify IndexNow servers about a new or updated URL with retry logic.
    
    Args:
        api_key (str): The IndexNow API key.
        url (str): The URL to notify.
    
    Returns:
        bool: True if all requests were sent successfully.
    """
    indexnow_servers = [
        "https://api.indexnow.org/indexnow",
        "https://www.bing.com/indexnow",
        "https://searchadvisor.naver.com/indexnow",
        "https://search.seznam.cz/indexnow",
        "https://yandex.com/indexnow",
        "https://indexnow.yep.com/indexnow"
    ]

    def notify_server(server_url):
        full_url = f"{server_url}?url={url}&key={api_key}"
        response = requests.get(full_url, timeout=10)
        if response.status_code == 200:
            logging.info(f"‚úÖ [IndexNow] Successfully notified {server_url} for URL: {url}")
        else:
            raise Exception(f"Request to {server_url} failed. Status code: {response.status_code}, Response: {response.text}")

    for server_url in indexnow_servers:
        try:
            retry_with_backoff(notify_server, server_url=server_url)
        except Exception as e:
            logging.error(f"‚ùå [IndexNow Error] Failed to notify {server_url}. Error: {e}")

    return True

def get_article_content(api_key, topic_idea, description, image_path):
    """Generate a blog article using OpenAI and save it to a file.
    
    Args:
        api_key (str): The OpenAI API key.
        topic_idea (str): The topic idea for the article.
        description (str): The description for the article.
        image_path (str): The path to the associated image.
    
    Returns:
        str: The path to the saved article file.
    """
    # Generate alt text for the image
    image_alt_text = generate_image_alt_text(api_key, topic_idea, description)

    prompt = f"""
    Create a blog article of approximately between 1200 to 2000 words in GitHub Flavored Markdown format.
    The article is for a blog related to the world of minerals, mining, or gemstones.
    The Audience: Geology enthusiasts, educators, and general readers interested in earth sciences
    
    - Topic Idea: {topic_idea}
    - Description: {description}
     
    **Front Matter**: Begin the article with the following front matter format:
       ---
       layout: post
       title: "<title of the generated article, do not use any symbol in the title, max 50 characters>"
       subtitle: "<summary of the generated article, max 140 characters>"
       excerpt_image: {WEBSITE}{image_path}
       categories: [<2 categories, comma separated for the generated article>]
       tags: [<4 keywords, comma separated for the generated article>]
       ---

    ![banner]({WEBSITE}{image_path} "{image_alt_text}")

    **Content**:
       - **Introduction**: Captivating introduction.
       - **Main Sections**: Detailed exploration and insights into topic.
       - **Quote**: Include a quote.
       - **Visual Elements**: A table to organize data or highlight key comparisons.
    **External Reference**: External link reference to a verified and relevant resource.
    **Conclusion**: Wrap up the article with a conclusion.
    """
    client = OpenAI(api_key=api_key)    
    response = client.chat.completions.create(
        model="gpt-4",
        messages=[
            {"role": "system", "content": "You are a helpful assistant."},
            {"role": "user", "content": prompt}
        ],
        max_tokens=3000,
        n=1,
        temperature=0.7,
    )
    article_content = response.choices[0].message.content.strip()

    article_content = article_content.replace('```markdown', '').replace('```', '').replace('``', '').strip()
    
    lines = article_content.split('\n')
    if lines[0].strip() == '':
        lines = lines[1:]
    article_content = '\n'.join(lines)

    current_date = datetime.now().strftime("%Y-%m-%d")
    article_file_path = os.path.join(AI_ARTICLES_DIRECTORY, f"""{current_date}-{topic_idea.replace(' ', '_').replace("'", '')}.md""")
    with open(article_file_path, 'w') as article_file:
        article_file.write(article_content)
    logging.info(f"‚úÖ Article for '{topic_idea}' created and saved to {article_file_path}")

    return article_file_path

def check_and_load_env_variables():
    """Check and load required and optional environment variables.
    
    Returns:
        tuple: A tuple containing the values of the environment variables.
    """
    logging.info("üîç Checking environment variables...")
    OPENAI_API_KEY = check_env_variable_error("OPENAI_API_KEY")
    TELEGRAM_BOT_TOKEN = check_env_variable_warning("TELEGRAM_BOT_TOKEN")
    TELEGRAM_CHAT_ID = check_env_variable_warning("TELEGRAM_CHAT_ID")
    INDEXNOW_API_KEY = check_env_variable_warning("INDEXNOW_API_KEY")
    return OPENAI_API_KEY, TELEGRAM_BOT_TOKEN, TELEGRAM_CHAT_ID, INDEXNOW_API_KEY

def ensure_directories_exist(*directories):
    """Ensure that the specified directories exist. Create them if they do not exist.
    
    Args:
        *directories (str): The paths of the directories to check or create.
    
    Returns:
        tuple: The input directories.
    """
    for directory in directories:
        os.makedirs(directory, exist_ok=True)
        logging.info(f"‚úÖ Ensured directory exists: {directory}")
    return directories

def initialize_files(*file_paths):
    """Ensure that the specified CSV files exist. Create them if they do not exist.
    
    Args:
        *file_paths (str): The paths of the CSV files to check or create.
    
    Returns:
        tuple: The input file paths.
    """
    for file_path in file_paths:
        initialize_csv(file_path)
    return file_paths

def create_article_with_image(api_key, bot_token, chat_id, file_path_new, file_path_archived, file_path_error, indexnow_api_key):
    """Generate an article with an image, archive the topic, and notify via Telegram and IndexNow.
    
    Args:
        api_key (str): The OpenAI API key.
        bot_token (str): The Telegram bot token.
        chat_id (str): The Telegram chat ID.
        file_path_new (str): The path to the CSV file for new topics.
        file_path_archived (str): The path to the CSV file for archived topics.
        file_path_error (str): The path to the CSV file for error topics.
        indexnow_api_key (str): The IndexNow API key.
    """
    exception_count = 0  # Counter to track the number of exceptions
    max_exceptions = 3  # Maximum number of allowed exceptions

    while exception_count < max_exceptions:
        logging.info("üîÑ Fetch the next topic idea and description...")
        # Fetch the next topic idea and description
        topic_idea, description = fetch_topic_and_description(file_path_new, api_key, bot_token, chat_id)
        
        logging.info(f"üîÑ Topic Idea: {topic_idea}, Description: {description}")

        try:
            logging.info("üîÑ Use the topic idea and description to request an image...")
            # Use the topic idea and description to request an image
            image_path = get_image_create_file_and_notify(api_key, AI_IMAGES_DIRECTORY, bot_token, chat_id, topic_idea, description)
            
            # Check if image generation failed
            if not image_path:
                raise Exception(f"Image generation failed for topic '{topic_idea}'. Moving to error topics.")

            logging.info("üîÑ Request the article content...")
            # Request the article content
            article_file_path = get_article_content(api_key, topic_idea, description, image_path)
            
            logging.info("üîÑ Add the topic idea and description to the archived topics file...")
            # Add the topic idea and description to the archived topics file
            write_to_csv(file_path_archived, topic_idea, description)
            
            logging.info("üîÑ Remove the used line from the new topics file...")
            # Remove the used line from the new topics file
            with open(file_path_new, 'r') as new_file:
                lines = new_file.readlines()
            with open(file_path_new, 'w') as new_file:
                new_file.writelines(lines[1:])
            
            logging.info(f"‚úÖ Topic '{topic_idea}' archived and removed from new topics.")

            # MOVED: Construct article URL and notify via Telegram & IndexNow here (at the end of create_article_with_image)
            current_date = datetime.now().strftime("%Y-%m-%d")
            
            with open(article_file_path, 'r') as file:
                article_content = file.read()

            # Extract categories from the front matter
            categories_match = re.search(r'categories: \[(.*?)\]', article_content)
            if categories_match:
                categories = [category.strip() for category in categories_match.group(1).split(',')]
                categories = [category.replace(' ', '%20').replace('&', '%26') for category in categories]
                category_path = '/'.join(categories).lower()
            else:
                category_path = "articles"  # default fallback if categories extraction fails
                logging.warning("‚ö†Ô∏è Categories extraction failed. Defaulted to /articles.")

            # Construct URL for your blog's format
            article_url = f"{WEBSITE}{category_path}/{current_date.replace('-', '/')}/{topic_idea.replace(' ', '_')}.html"

            # Replace single quotes with an empty string as required
            article_url = article_url.replace("'", '')

            send_telegram_message(bot_token, chat_id, f"New article for '{topic_idea}' has been generated and saved. Read it here: {article_url}")

            if indexnow_api_key:
                notify_indexnow(api_key=indexnow_api_key, url=article_url)
            else:
                logging.warning("‚ö†Ô∏è No INDEXNOW_API_KEY found. IndexNow notification will not be sent.")

            break  # Exit the loop if successful

        except Exception as e:
            exception_count += 1  # Increment the exception counter
            logging.error(f"‚ùå Error occurred: {e}")
            
            # Move the topic to the ERROR topics file
            logging.info("üîÑ Moving the topic to ERROR topics...")
            write_to_csv(file_path_error, topic_idea, description)
            
            # Send a Telegram message about the error
            send_telegram_message(bot_token, chat_id, f"‚ùå Error occurred while processing topic '{topic_idea}'. Moved to ERROR topics. Error: {e}")

            # Continue to the next topic
            logging.info(f"üîÑ Retrying with a new topic. Attempt {exception_count}/{max_exceptions}")

    if exception_count >= max_exceptions:
        logging.error(f"‚ùå Maximum number of exceptions ({max_exceptions}) reached. Stopping the process.")
        send_telegram_message(bot_token, chat_id, f"‚ùå Maximum number of exceptions ({max_exceptions}) reached. Stopping the process.")
        
def main():
    """Main function to initialize environment variables, directories, and files, 
    and generate articles with images."""
    OPENAI_API_KEY, TELEGRAM_BOT_TOKEN, TELEGRAM_CHAT_ID, INDEXNOW_API_KEY = check_and_load_env_variables()
    ensure_directories_exist(AI_TOPICS_DIRECTORY, AI_IMAGES_DIRECTORY, AI_ARTICLES_DIRECTORY)
    
    # Initialize all required CSV files, including the error topics file
    FILE_PATH_NEW_TOPICS = os.path.join(AI_TOPICS_DIRECTORY, CSV_FILE_LIST_OF_NEW_TOPICS)
    FILE_PATH_ARCHIVED_TOPICS = os.path.join(AI_TOPICS_DIRECTORY, CSV_FILE_LIST_OF_ARCHIVED_TOPICS)
    FILE_PATH_ERROR_TOPICS = os.path.join(AI_TOPICS_DIRECTORY, CSV_FILE_LIST_OF_ERROR_TOPICS)

    # Ensure the files are created if they don't exist
    initialize_csv(FILE_PATH_NEW_TOPICS)
    initialize_csv(FILE_PATH_ARCHIVED_TOPICS)
    initialize_csv(FILE_PATH_ERROR_TOPICS)

    logging.info("üîÑ Initializing OpenAI requests...")
    create_article_with_image(
        OPENAI_API_KEY, 
        TELEGRAM_BOT_TOKEN, 
        TELEGRAM_CHAT_ID, 
        FILE_PATH_NEW_TOPICS, 
        FILE_PATH_ARCHIVED_TOPICS, 
        FILE_PATH_ERROR_TOPICS, 
        INDEXNOW_API_KEY
    )
    logging.info("‚úÖ Script completed!")

if __name__ == "__main__":
    main()